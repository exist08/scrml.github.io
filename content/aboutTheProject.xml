<page>
    <p>Proofs are a particular way of thinking that many students struggle with when first learning. Proofs are given in natural language (English) but there are rigid structural rules sentences must follow in order to be considered valid. This is especially true for key logical words like "or, and, not, if, suppose." Additionally if a transition word like "thus" or "therefore" is out of place the proof becomes confusing, if not absolutely incorrect.</p>
    <p>The rigid structure of proofs seems familiar to those of us who know a computer programming language. With computers, syntax is essential. Any small deviation from the required structure will halt execution of the program. Likewise, a small change in wording in a proof can turn a perfectly valid statement into total nonsense. Perhaps more insidiously, a small change in wording can turn one sentence into another valid sentence but completely change the meaning, a phenomenon all too familiar to anyone who has had to debug a program.</p>
    <p>The similarities between mathematical proofs and computer programs does not end with structural rigidity. Perhaps more importantly, both are treated as absolutely and inherently consistent. That is, computers do not make mistakes when executing code -- the mistakes come from code design (we won't consider hardware malfunctions). Likewise a proof is, by virtue of being a proof, always correct. If an attempted proof is incorrect then we do not say that something is wrong with proof itself, we say that something is wrong with the argument given as proof (sometimes we call the argument a proof, which may be confusing now, but we can always distinguish between a proposed argument and a valid proof). In both situations problems are assumed to come from either the author for making a mistake or the consumer for misinterpreting the material. The material itself is infallibly consistent and purely logical.</p>
    <p>Recognizing this leads us to the point of this project: computers should be able to understand abstract mathematics in the same way that we mathematicians do. Obiously we cannot expect creativity or ingenuity from a computer, and a computer cannot understand the beauty or appeal of mathematics, but a computer should be able to read an argument and check if it makes sense or not, provided we have determined the qualifications for what a statement is and what it means to make sense. This project aims to create a language in which we can make mathematical statements in such an unambiguous and uniform way that a computer can process it, and to have algorithmic checks in place to define what we mean by making sense. Moreover we would like the language to be as immediately recognizable as possible to the everyday mathematician. Any person who is familiar with the standard concepts of mathematical proof should be able to write statements in this language with a minimal amount of esoteric knowledge about the language itself.</p>
    <p>The goal is specifically to develop a language for computers to understand mathematical statements, what we make them then do with the statements is left for future projects. This language was born from an idea about a cheesy video game designed to teach calculus. The idea is that the game is an RPG where the player explores a medieval fantasy world full of goblins, ogres, dragons, and other monsters. Any encounter with a monster initiates a fight which consists of the monster asking calculus questions. The player has a toolbelt of all the theorems learned so far, and they try to piece together a solution using these theorems. If they succeed then they progress in the game, and if not they turn around and explore for more theorems. The world would be populated with friendly villagers who show example problems tohelp the player along.</p>
    <p>The key part of this game is that the player is capable of creating their own theorems to add to the toolbelt during gameplay. This is different from the standard approach of fill-in-the-blank until the correct answer is obtained. In this game a clever player could create the solution to any question as long as the solution is correct -- even questions the game's author does not know how to solve. Doing this requires that the computer running the game has a way of checking if the solution is correct. It also requires that the player know the language used to construct solutions, so this language should be matched as closely as possible to the existing standard format of mathematical communication. Hence we have motivation to create this language. Of course, there are other potential applications for the language too.</p>
</page>